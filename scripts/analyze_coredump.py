#!/usr/bin/env python3
"""
ESP32 Core Dump Analyzer for PlatformIO Projects

This script analyzes ESP32 core dumps generated by PlatformIO projects.
It extracts the ELF core dump from ESP32's proprietary format and uses
GDB to provide detailed crash analysis.

Usage:
    python3 scripts/analyze_coredump.py <coredump_file> [environment_or_elf_file] [elf_file]
    
Examples:
    python3 scripts/analyze_coredump.py /path/to/support.bin
    python3 scripts/analyze_coredump.py /path/to/support.bin display
    python3 scripts/analyze_coredump.py /path/to/support.bin controller
    python3 scripts/analyze_coredump.py /path/to/support.bin display-headless
    python3 scripts/analyze_coredump.py /path/to/support.bin /path/to/firmware.elf
    python3 scripts/analyze_coredump.py /path/to/support.bin display /path/to/firmware.elf

Environments:
    display           - Main display controller (default)
    controller        - Gaggia controller
    display-headless  - Headless display mode

Author: Generated for Gaggimate project
"""

import os
import sys
import subprocess
import tempfile
import shutil
import json
import base64
from pathlib import Path

def find_pio_build_dir(environment="display"):
    """Find the PlatformIO build directory for the given environment."""
    build_dir = Path(".pio/build") / environment
    if not build_dir.exists():
        print(f"‚ùå Build directory not found: {build_dir}")
        
        # List available environments
        pio_build_root = Path(".pio/build")
        if pio_build_root.exists():
            available_envs = [d.name for d in pio_build_root.iterdir() if d.is_dir()]
            if available_envs:
                print(f"   Available environments: {', '.join(available_envs)}")
            else:
                print("   No built environments found.")
        
        print("   Please build the project first with: pio run")
        print(f"   Or build specific environment: pio run -e {environment}")
        return None
    return build_dir

def find_firmware_elf(build_dir):
    """Find the firmware ELF file in the build directory."""
    elf_file = build_dir / "firmware.elf"
    if not elf_file.exists():
        print(f"‚ùå Firmware ELF not found: {elf_file}")
        print("   Please build the project first with: pio run")
        return None
    return elf_file

def find_gdb_executable():
    """Find the ESP32-S3 GDB executable."""
    # Try ESP-IDF path first
    gdb_paths = [
        "xtensa-esp32s3-elf-gdb",  # In PATH
        "xtensa-esp32-elf-gdb",    # Generic ESP32 GDB (fallback)
        os.path.expanduser("~/.espressif/tools/xtensa-esp-elf-gdb/*/xtensa-esp-elf-gdb/bin/xtensa-esp32s3-elf-gdb"),
        os.path.expanduser("~/.espressif/tools/xtensa-esp-elf-gdb/*/xtensa-esp-elf-gdb/bin/xtensa-esp32-elf-gdb"),
        # PlatformIO paths
        os.path.expanduser("~/.platformio/packages/toolchain-xtensa-esp32s3/bin/xtensa-esp32s3-elf-gdb"),
        os.path.expanduser("~/.platformio/packages/toolchain-xtensa-esp32/bin/xtensa-esp32-elf-gdb"),
    ]
    
    for gdb_path in gdb_paths:
        if "*" in gdb_path:
            # Handle glob patterns
            import glob
            matches = glob.glob(gdb_path)
            if matches:
                gdb_path = matches[0]
        
        if shutil.which(gdb_path) or os.path.exists(gdb_path):
            print(f"‚úÖ Found GDB: {gdb_path}")
            return gdb_path
    
    print("‚ùå ESP32 GDB not found!")
    print("   Please install ESP-IDF or ensure PlatformIO toolchain is available")
    print("   Tried looking for:")
    for path in gdb_paths:
        print(f"     - {path}")
    return None

def extract_elf_from_coredump(coredump_file):
    """Extract ELF core dump from ESP32 proprietary format."""
    try:
        with open(coredump_file, 'rb') as f:
            data = f.read()
        
        # Find ELF header (0x7f 'E' 'L' 'F')
        elf_start = data.find(b'\x7fELF')
        if elf_start == -1:
            print("‚ùå No ELF header found in core dump")
            return None
        
        print(f"‚úÖ ELF header found at offset: {elf_start}")
        
        # Extract ELF data
        elf_data = data[elf_start:]
        
        # Create temporary file
        temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.elf')
        temp_file.write(elf_data)
        temp_file.close()
        
        print(f"‚úÖ Extracted ELF core dump to: {temp_file.name}")
        print(f"   Original size: {len(data)} bytes, ELF size: {len(elf_data)} bytes")
        
        return temp_file.name
        
    except Exception as e:
        print(f"‚ùå Failed to extract ELF from core dump: {e}")
        return None

def analyze_with_gdb(gdb_path, firmware_elf, coredump_elf):
    """Analyze core dump using GDB."""
    print("\n" + "="*80)
    print("üîç CORE DUMP ANALYSIS")
    print("="*80)
    
    # GDB commands to run
    gdb_commands = [
        f"core-file {coredump_elf}",
        "bt",  # Backtrace
        "info registers",  # Register dump
        "info threads",  # Thread information
        "thread apply all bt",  # Backtrace for all threads
        "quit"
    ]
    
    # Create GDB command file
    with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.gdb') as cmd_file:
        for cmd in gdb_commands:
            cmd_file.write(f"{cmd}\n")
        cmd_file_path = cmd_file.name
    
    try:
        # Run GDB
        result = subprocess.run([
            gdb_path,
            firmware_elf,
            "-x", cmd_file_path,
            "--batch"
        ], capture_output=True, text=True, timeout=60)
        
        print("üìã GDB OUTPUT:")
        print("-" * 40)
        if result.stdout:
            print(result.stdout)
        if result.stderr:
            print("STDERR:", result.stderr)
        
        return result.returncode == 0
        
    except subprocess.TimeoutExpired:
        print("‚ùå GDB analysis timed out")
        return False
    except Exception as e:
        print(f"‚ùå GDB analysis failed: {e}")
        return False
    finally:
        # Clean up command file
        try:
            os.unlink(cmd_file_path)
        except:
            pass

def print_crash_summary(coredump_file):
    """Print a summary and recommendations."""
    print("\n" + "="*80)
    print("üìä CRASH ANALYSIS SUMMARY")
    print("="*80)
    print(f"Core dump file: {coredump_file}")
    print("\nüí° NEXT STEPS:")
    print("1. Look at the backtrace (bt) to see the call stack")
    print("2. Check the exact line where the crash occurred")
    print("3. Look for null pointer dereferences or memory access violations")
    print("4. Check register 'pc' (program counter) for the crash address")
    print("5. Use 'info locals' in interactive GDB for variable values")
    print("\nüîß INTERACTIVE ANALYSIS:")
    print("For deeper analysis, run GDB interactively:")
    print(f"   xtensa-esp32s3-elf-gdb .pio/build/display/firmware.elf")
    print(f"   (gdb) core-file /tmp/extracted_coredump.elf")
    print(f"   (gdb) bt")
    print(f"   (gdb) list")
    print(f"   (gdb) info locals")

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 scripts/analyze_coredump.py <coredump_file> [environment_or_elf_file] [elf_file]")
        print("")
        print("Available environments:")
        print("  display           - Main display controller (default)")
        print("  controller        - Gaggia controller")  
        print("  display-headless  - Headless display mode")
        print("")
        print("Examples:")
        print("  python3 scripts/analyze_coredump.py ~/Downloads/coredump.bin")
        print("  python3 scripts/analyze_coredump.py ~/Downloads/coredump.bin display")
        print("  python3 scripts/analyze_coredump.py ~/Downloads/coredump.bin controller")
        print("  python3 scripts/analyze_coredump.py ~/Downloads/coredump.bin /path/to/firmware.elf")
        print("  python3 scripts/analyze_coredump.py ~/Downloads/coredump.bin display /path/to/firmware.elf")
        sys.exit(1)
    
    support_file = sys.argv[1]
    support_data = {
        'versions': {
            'displayVersion': 'unknown'
        }
    }

    coredump_file = "coredump.bin"
    with open(support_file, 'r') as f:
        support_data = json.load(f)
        coredump = support_data['coredump']
        coredump_binary = base64.b64decode(coredump)
        with open(coredump_file, 'wb') as f2:
            f2.write(coredump_binary)



    # Parse arguments - support both environment and direct ELF file specification
    environment = "display"  # default
    custom_elf_file = None
    
    if len(sys.argv) >= 3:
        second_arg = sys.argv[2]
        # Check if second argument is an ELF file (has .elf extension or is an absolute/relative path)
        if second_arg.endswith('.elf') or '/' in second_arg or '\\' in second_arg:
            custom_elf_file = second_arg
        else:
            environment = second_arg
    
    if len(sys.argv) >= 4:
        custom_elf_file = sys.argv[3]
    
    print("üöÄ ESP32 Core Dump Analyzer")
    print("="*50)
    displayVersion = 'unknown'
    if 'displayVersion' in support_data['versions']:
        displayVersion = support_data['versions']['displayVersion']
    print(f"Version: {displayVersion}")
    print(f"Support file: {support_file}")
    print(f"Core dump: {coredump_file}")
    if custom_elf_file:
        print(f"ELF file: {custom_elf_file}")
    else:
        print(f"Environment: {environment}")
    print()
    
    # Validate input file
    if not os.path.exists(coredump_file):
        print(f"‚ùå Core dump file not found: {coredump_file}")
        sys.exit(1)
    
    # Determine firmware ELF file
    if custom_elf_file:
        if not os.path.exists(custom_elf_file):
            print(f"‚ùå Custom ELF file not found: {custom_elf_file}")
            sys.exit(1)
        firmware_elf = Path(custom_elf_file)
        print(f"‚úÖ Using custom ELF file: {firmware_elf}")
    else:
        # Find build artifacts using environment
        build_dir = find_pio_build_dir(environment)
        if not build_dir:
            sys.exit(1)
        
        firmware_elf = find_firmware_elf(build_dir)
        if not firmware_elf:
            sys.exit(1)
    
    # Find GDB
    gdb_path = find_gdb_executable()
    if not gdb_path:
        sys.exit(1)
    
    # Extract ELF from core dump
    coredump_elf = extract_elf_from_coredump(coredump_file)
    if not coredump_elf:
        sys.exit(1)
    
    try:
        # Analyze with GDB
        success = analyze_with_gdb(gdb_path, str(firmware_elf), coredump_elf)
        
        # Print summary
        print_crash_summary(coredump_file)
        
        if success:
            print("\n‚úÖ Analysis completed successfully!")
        else:
            print("\n‚ö†Ô∏è  Analysis completed with warnings")
            
    finally:
        # Clean up temporary file
        try:
            os.unlink(coredump_elf)
        except:
            pass

if __name__ == "__main__":
    main()
